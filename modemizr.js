// Generated by CoffeeScript 1.10.0

/*
 * Text is easy to handle, but what to do with HTML elements?
 *
 * One could of course ignore any formatting and just use
 * textContent. That works of course.
 *
 * Another way is to handle text-like formatting (**not** IMG, HR etc.)
 * so that they are output too, but with their contents at the correct
 * pace. This requires tracking **what** element you are currently
 * appending to and what you are reading **from**.
 *
 * For simplicity let's look at <b>abc</b>. We start with an empty
 * output and start scanning the input element's contents. We hit the
 * B element.
 *
 * Now set a new B element (or better still, a copy of the original to
 * keep classes etc. intact but drop content) as output target. Start
 * scanning B's contents.
 *
 * Encounter string "abc". Take "a", put it to the output B element and
 * put "bc" back as "to be scanned".
 *
 * Keep doing this until hitting the end of scan list (e.g. end of
 * string).
 *
 * For deeper structure this needs of course stacks to keep the state.
 *
 */

(function() {
  var $, Modemizr, Pause, log, stringp, time,
    slice = [].slice;

  stringp = function(s) {
    return typeof s === 'string' || s instanceof String;
  };

  log = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
  };

  time = function() {
    return (new Date()).getTime();
  };

  Pause = (function() {
    Pause.prototype.ticks = 0;

    function Pause(chars1, secs1) {
      this.chars = chars1;
      this.secs = secs1;
      this.start = time();
      this.done = this.donep();
    }

    Pause.prototype.donep = function() {
      var pending;
      log("donep: ticks " + this.ticks + " chars " + this.chars + " elapsed " + (time() - this.start) + " secs " + this.secs);
      pending = ((this.chars != null) && this.ticks < this.chars) || ((this.secs != null) && (time() - this.start) < (1000.0 * this.secs));
      log("pending: " + pending);
      return !pending;
    };

    Pause.prototype.tick = function() {
      this.ticks++;
      return this.done = this.donep();
    };

    return Pause;

  })();

  Modemizr = (function() {
    Modemizr.prototype.bps = 1200;


    /*
     * Output is a stack of output elements. It starts with the initial
     * `output` container given at init.
     */

    Modemizr.prototype.output = [];


    /*
     * Input is an stack of arrays. When an empty array is encountered,
     * then output value is removed. Similarly if output needs to
     * recurse, then a new input array is pushed in.
     */

    Modemizr.prototype.input = [];


    /*
     * Output should always be a single node, input can either be an
     * array of elements, or a single element. If a single element is
     * given then its **child nodes** are used, not the node itself.
     */

    function Modemizr(output, input) {
      var child, nodes;
      if (output == null) {
        return;
      }
      if (input == null) {
        input = output;
      }
      this.output = [output];

      /*
       * If input is the same as output, grab node content first and then
       * clear it.
       */
      if (output === input) {
        nodes = Array.prototype.slice.call(input.childNodes);
        while ((child = input.firstChild) != null) {
          input.removeChild(child);
        }
        input = nodes;
      }

      /*
       * If we are passed a plain input node grab its children only.
       */
      if (!(input instanceof Array)) {
        input = input.childNodes;
      }

      /*
       * ... and remember to use slice to ensure it is a true array, not
       * an object of childNodes
       */
      this.input = [Array.prototype.slice.call(input)];
      log("output", this.output, "input", this.input);
    }

    Modemizr.prototype.restart = function() {
      this.stop();
      return this.start();
    };

    Modemizr.prototype.start = function() {
      var interval;
      if (this.timer != null) {
        return;
      }
      interval = 1000.0 / (this.bps / 10.0);
      this.last = (new Date()).getTime();
      this.timer = setInterval(((function(_this) {
        return function() {
          return _this.tick();
        };
      })(this)), interval);
      return this;
    };

    Modemizr.prototype.stop = function() {
      if (this.timer != null) {
        clearInterval(this.timer);
      }
      this.timer = null;
      return this;
    };


    /*
     * Count the number of characters that shold be output to keep the
     * BPS value correct since `last` when now is `now`.
     */

    Modemizr.prototype.countCharsNeeded = function(last, now) {
      var chars, elapsed;
      elapsed = now - last;
      chars = Math.round(elapsed / (1000.0 / (this.bps / 10.0)));
      return chars;
    };

    Modemizr.prototype.tick = function() {
      var chars, now, results;
      if (this.input.length === 0) {
        this.stop();
        return;
      }
      now = (new Date()).getTime();
      chars = this.countCharsNeeded(this.last, now);
      if (chars > 0) {
        this.last = now;
        results = [];
        while (chars-- > 0) {
          results.push(this.step());
        }
        return results;
      }
    };

    Modemizr.prototype.pop_both = function() {
      this.output.pop();
      return this.input.pop();
    };

    Modemizr.prototype.pop_output = function() {
      return this.output.pop();
    };

    Modemizr.prototype.push_both = function(node, content) {
      this.output[this.output.length - 1].appendChild(node);
      this.output.push(node);
      return this.input.push(content);
    };

    Modemizr.prototype.push_output = function(node) {
      return this.output.push(node);
    };


    /*
     * Remove the current head element of the top input. Remember, input
     * is a stack of arrays.
     */

    Modemizr.prototype.drop_input = function() {
      return this.input[this.input.length - 1].shift();
    };


    /*
     * Produce output of "one character" or its equivalent.
     */

    Modemizr.prototype.step = function() {
      var bps, chars, current, input, node, output, ref, secs;
      if (this.input.length === 0 || this.output.length === 0) {
        return;
      }
      output = this.output[this.output.length - 1];
      input = this.input[this.input.length - 1];
      if (output instanceof Pause) {
        log("pausing");
        output.tick();
        if (!output.done) {
          return;
        }
        this.pop_output();
        return this.step;
      }
      if (input.length === 0) {
        this.pop_both();
        return this.step();
      }
      current = input[0];
      log("current", current);

      /*
       * If it is a plain string, easy -- pick one character and append
       * to output (it will always be a Text element at this point).
       */
      if (stringp(current)) {
        if (current.length === 0) {
          this.drop_input();
          return this.step();
        }
        log("plain string", current);
        output.textContent += current[0];
        input[0] = current.slice(1);
        return;
      }
      log("not string");

      /*
       * All other types get dropped from the input and replaced with
       * something else (a new element on the stack or ignored.)
       */
      this.drop_input();

      /*
       * If it is Text node, add an empty text node to output and push
       * its text value to input. This is because we should only append
       * characters to text nodes -- without this styles would pop out of
       * existence at the end of an element.
       */
      if (current.nodeType === 3) {
        log("string node");
        node = current.cloneNode();
        node.textContent = "";
        this.push_both(node, [current.textContent]);
        return this.step();
      }
      if (current.nodeType === 8) {
        log("comment node");
        return this.step();
      }

      /*
       * If it is a formatting style element then recurse into it.
       */
      if ((ref = current.tagName) === 'B' || ref === 'I' || ref === 'TT' || ref === 'EMPH' || ref === 'SPAN' || ref === 'DIV' || ref === 'P' || ref === 'PRE' || ref === 'A' || ref === 'IMG' || ref === 'BR' || ref === 'H1' || ref === 'H2' || ref === 'H3' || ref === 'H4' || ref === 'H5' || ref === 'DL' || ref === 'DT' || ref === 'DD' || ref === 'OT' || ref === 'OL' || ref === 'LI' || ref === 'UL') {
        log("formatting node");
        node = current.cloneNode();
        this.push_both(node, Array.prototype.slice.call(current.childNodes));
        chars = node.getAttribute('data-pause-chars');
        secs = node.getAttribute('data-pause-secs');
        if ((chars != null) || (secs != null)) {
          this.push_output(new Pause((chars != null) && parseFloat(chars) || null, (secs != null) && parseFloat(secs) || null));
        }
        bps = node.getAttribute('data-bps');
        if (bps != null) {
          this.bps = parseFloat(bps);
          this.restart();
        }
        return this.step();
      }
      console.log("Unrecognized node type " + current.nodeType + " with tag " + current.tagName + ", skipping.");
      return this.step();
    };

    return Modemizr;

  })();


  /*
   * Global initializer
   */

  window.modemizr = function(output, input) {
    return (new Modemizr(output, input)).start();
  };


  /*
   * If jQuery is available, add a jQuery plugin.
   */

  if (($ = window.jQuery) != null) {
    $.fn.modemizr = function(options) {
      return this.each(function() {
        return (new Modemizr(this, this, options)).start();
      });
    };
  }

  window.blink = function(elt) {
    var tick;
    tick = (function(_this) {
      return function() {
        return elt.classList.toggle("blink");
      };
    })(this);
    return setInterval(tick, 500.0);
  };

}).call(this);
